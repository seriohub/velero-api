pipeline {
    agent any

    environment {
        // Environment variables

        // Source code repository
        evGit_Source_Code = 'https://github.com/seriohub/velero-api'

        // Default docker registry  (Global environment variable setting)
        evDocker_HUB = "${env.DEFAULT_DOCKER_REGISTRY}"

        // Author name
        evDocker_Project = "${env.DOCKER_AUTHOR}"

        // Credential stored in Jenkins Credential for logging in the HUB
        evDocker_HUB_Credentials = credentials('DEFAULT_DOCKER_CREDENTIALS')

        evTarget = 'velero-api'
        evLatestTag = ''
        evCommitChangeset = ''
    }
    stages {
        stage('Clone Git Repository') {
            steps {
                script {
                    echo 'Clone Git repository...'

                    // Clone the GitHub repository
                    checkout([$class: "GitSCM", branches: [[name: "*/dev"]], userRemoteConfigs: [[url: evGit_Source_Code]]])

                    // Get commit changes
                    evCommitChangeset = sh(returnStdout: true, script: "git log -1 --pretty='%s'").trim()
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    echo 'Build Docker Image...'

                    // Path to your Dockerfile within the project directory
                    def dockerfilePath = 'docker/Dockerfile'
                    def dockerHubProject = "${evDocker_Project}/${evTarget}"

                    GIT_TAG = 'dev'
                    def now=new Date()

                    // Build the Docker image, specifying the Dockerfile path
                    # sh "docker build --build-arg VERSION=dev --build-arg BUILD_DATE=${now.format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone('UTC'))} --target ${evTarget} -t ${dockerHubProject}:${GIT_TAG} -f ${dockerfilePath} ."
                    sh "docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7 --build-arg VERSION=dev --build-arg BUILD_DATE=${now.format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone('UTC'))} --target ${evTarget} -t ${dockerHubProject}:${GIT_TAG} -f ${dockerfilePath} ."
                }
            }
        }

        stage('Push Docker Image to Registry') {
            steps {
                script {
                    echo "Docker registry: ${evDocker_HUB}"
                    def pushTo = ''
                    if (evDocker_HUB != null) {
                        if (evDocker_HUB != '' && !evDocker_HUB.contains('null')) {
                            pushTo = "$evDocker_HUB"
                        }
                    }

                    sh "echo ${evDocker_HUB_Credentials_PSW} | docker login -u ${evDocker_HUB_Credentials_USR} --password-stdin ${pushTo}"

                    def dockerImageName = "$evDocker_Project/$evTarget"

                    if (evDocker_HUB != null) {
                        if (evDocker_HUB != '' && !evDocker_HUB.contains('null')) {
                            dockerImageName = "$evDocker_HUB/$evDocker_Project/$evTarget"
                        }
                    }

                    echo "Docker push to:- ${dockerImageName} -"
                    sh "docker push ${dockerImageName}:${GIT_TAG}"
                    // sh "docker push ${dockerImageName}:latest"
                    sh 'docker logout '
                }
            }
        }
    }
    post {
        always {
            script {
                echo 'Post always...'
                def pipelineName = currentBuild.fullProjectName
                def message = ''

                if (currentBuild.resultIsBetterOrEqualTo('SUCCESS')) {
                    message = "Jenkins Pipeline ${pipelineName}: Your developer image version has been successfully pushed to the Docker Registry.\nCommit changes:\n ${evCommitChangeset}"
                } else {
                    message = "Jenkins Pipeline ${pipelineName}: Build failed"
                }

                def url = "https://api.telegram.org/bot${env.TELEGRAM_TOKEN}/sendMessage"
                def payload = [
                    chat_id: "${env.TELEGRAM_CHAT_ID}",
                    text: message
                ]

                def response = httpRequest(
                    url: url,
                    httpMode: 'POST',
                    contentType: 'APPLICATION_JSON',
                    requestBody: groovy.json.JsonOutput.toJson(payload)
                )

                if (response.status == 200) {
                    echo 'Telegram message sent successfully'
                } else {
                    error "Failed to send Telegram message. Status code: ${response.status}"
                }
            }
        }
    }
}
